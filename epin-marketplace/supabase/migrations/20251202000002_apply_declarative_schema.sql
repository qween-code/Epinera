-- Combined declarative schema migration
-- Generated from supabase/schemas/*.sql files
-- DO NOT EDIT THIS FILE MANUALLY - Regenerate using: npx tsx scripts/consolidate-schemas.ts

-- ============================================
-- File: 01_enums.sql
-- ============================================

-- ============================================
-- ENUM TYPES
-- ============================================
-- All custom enum types used throughout the database schema

-- User role enum
CREATE TYPE public.user_role AS ENUM ('buyer', 'seller', 'creator', 'admin');

-- KYC status enum
CREATE TYPE public.kyc_status AS ENUM ('not_started', 'pending', 'verified', 'rejected');

-- Product status enum
CREATE TYPE public.product_status AS ENUM ('draft', 'active', 'inactive', 'sold_out', 'suspended', 'deleted');

-- Delivery type enum
CREATE TYPE public.delivery_type AS ENUM ('instant', 'email', 'in_game_mail', 'trade', 'guild_invite', 'manual', 'other');

-- Order status enum
CREATE TYPE public.order_status AS ENUM ('pending', 'pending_payment', 'processing', 'completed', 'cancelled', 'failed', 'refunded', 'disputed');

-- Payment status enum
CREATE TYPE public.payment_status AS ENUM ('pending', 'paid', 'failed', 'refunded');

-- Payment method enum
CREATE TYPE public.payment_method AS ENUM ('credit_card', 'paypal', 'bank_transfer', 'crypto');

-- Escrow status enum
CREATE TYPE public.escrow_status AS ENUM (
  'initiated',
  'payment_held',
  'awaiting_delivery',
  'delivered',
  'confirmed',
  'completed',
  'disputed',
  'under_review',
  'expired',
  'auto_refund'
);

-- Delivery status enum
CREATE TYPE public.delivery_status AS ENUM (
  'pending',
  'processing',
  'delivered',
  'confirmed',
  'failed',
  'cancelled'
);

-- Moderation status enum
CREATE TYPE public.moderation_status AS ENUM (
  'pending',
  'approved',
  'rejected',
  'flagged'
);

-- Event type enum for analytics
CREATE TYPE public.event_type AS ENUM (
  'page_view',
  'product_view',
  'add_to_cart',
  'purchase',
  'search',
  'click',
  'scroll',
  'video_play',
  'form_submit',
  'login',
  'signup'
);

-- Audit action enum
CREATE TYPE public.audit_action AS ENUM (
  'create',
  'update',
  'delete',
  'suspend',
  'verify',
  'refund',
  'data_export',
  'login',
  'logout',
  'permission_change'
);

-- Achievement tier enum
CREATE TYPE public.achievement_tier AS ENUM (
  'bronze',
  'silver',
  'gold',
  'platinum',
  'diamond'
);



-- ============================================
-- File: 02_profiles.sql
-- ============================================

-- ============================================
-- PROFILES TABLE
-- ============================================
-- User profiles extending auth.users

CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  full_name TEXT,
  avatar_url TEXT,
  phone TEXT UNIQUE,
  role public.user_role NOT NULL DEFAULT 'buyer',
  kyc_status public.kyc_status NOT NULL DEFAULT 'not_started',

  CONSTRAINT phone_length CHECK (
    phone IS NULL OR char_length(phone) >= 10
  )
);

-- Indexes
CREATE INDEX idx_profiles_role ON public.profiles(role);
CREATE INDEX idx_profiles_kyc_status ON public.profiles(kyc_status);

-- Comments
COMMENT ON TABLE public.profiles IS 'User profiles extending Supabase auth.users';
COMMENT ON COLUMN public.profiles.role IS 'User role: buyer, seller, creator, or admin';
COMMENT ON COLUMN public.profiles.kyc_status IS 'KYC verification status';



-- ============================================
-- File: 03_categories.sql
-- ============================================

-- ============================================
-- CATEGORIES TABLE
-- ============================================
-- Product categories with hierarchical support

CREATE TABLE public.categories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  parent_id UUID REFERENCES public.categories(id) ON DELETE SET NULL,
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_categories_parent_id ON public.categories(parent_id);
CREATE INDEX idx_categories_slug ON public.categories(slug);

-- Comments
COMMENT ON TABLE public.categories IS 'Product categories with hierarchical support';
COMMENT ON COLUMN public.categories.parent_id IS 'For sub-categories';



-- ============================================
-- File: 04_products.sql
-- ============================================

-- ============================================
-- PRODUCTS TABLES
-- ============================================
-- Products, product variants, attributes, and variant attributes

-- Products table (base product/template)
CREATE TABLE public.products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  seller_id UUID REFERENCES public.profiles(id) NOT NULL,
  category_id UUID REFERENCES public.categories(id) NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  slug TEXT UNIQUE,
  image_url TEXT,
  -- Game-specific metadata
  digital_content JSONB,
  delivery_method public.delivery_type,
  average_delivery_time INTERVAL,
  status public.product_status DEFAULT 'draft',
  seo_metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Product Variants table
CREATE TABLE public.product_variants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  product_id UUID REFERENCES public.products(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL, -- e.g., "850 VP", "1 Month Subscription"
  price DECIMAL(10, 2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'TRY',
  stock_quantity INTEGER DEFAULT 0,
  status public.product_status DEFAULT 'draft',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Attributes table (for reusable properties)
CREATE TABLE public.attributes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT UNIQUE NOT NULL -- e.g., "Delivery Speed", "Region"
);

-- Linking attributes to product variants (many-to-many)
CREATE TABLE public.product_variant_attributes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  variant_id UUID REFERENCES public.product_variants(id) ON DELETE CASCADE NOT NULL,
  attribute_id UUID REFERENCES public.attributes(id) ON DELETE CASCADE NOT NULL,
  value TEXT NOT NULL, -- e.g., "Instant", "Turkey"
  UNIQUE(variant_id, attribute_id)
);

-- Indexes
CREATE INDEX idx_products_seller_id ON public.products(seller_id);
CREATE INDEX idx_products_category_id ON public.products(category_id);
CREATE INDEX idx_products_slug ON public.products(slug);
CREATE INDEX idx_products_image_url ON public.products(image_url) WHERE image_url IS NOT NULL;
CREATE INDEX idx_product_variants_product_id ON public.product_variants(product_id);
CREATE INDEX idx_product_variant_attributes_variant_id ON public.product_variant_attributes(variant_id);
CREATE INDEX idx_product_variant_attributes_attribute_id ON public.product_variant_attributes(attribute_id);

-- Comments
COMMENT ON TABLE public.products IS 'Base product templates';
COMMENT ON TABLE public.product_variants IS 'Specific product variants with pricing and stock';
COMMENT ON TABLE public.attributes IS 'Reusable product attributes';
COMMENT ON TABLE public.product_variant_attributes IS 'Many-to-many relationship between variants and attributes';
COMMENT ON COLUMN public.products.image_url IS 'URL of the product image';



-- ============================================
-- File: 05_orders.sql
-- ============================================

-- ============================================
-- ORDERS TABLES
-- ============================================
-- Orders and order items

CREATE TABLE public.orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  buyer_id UUID REFERENCES public.profiles(id) NOT NULL,
  total_amount DECIMAL(10, 2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'TRY',
  status public.order_status DEFAULT 'pending',
  payment_status public.payment_status DEFAULT 'pending',
  payment_method public.payment_method,
  -- Checkout fields
  subtotal DECIMAL(10, 2),
  discount_amount DECIMAL(10, 2) DEFAULT 0,
  tax_amount DECIMAL(10, 2) DEFAULT 0,
  shipping_address JSONB,
  billing_address JSONB,
  notes TEXT,
  delivery_info JSONB, -- Contact info, delivery preferences, etc.
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Order items table
CREATE TABLE public.order_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID REFERENCES public.orders(id) ON DELETE CASCADE NOT NULL,
  variant_id UUID REFERENCES public.product_variants(id) NOT NULL,
  product_id UUID REFERENCES public.products(id) NOT NULL,
  seller_id UUID REFERENCES public.profiles(id) NOT NULL,
  quantity INTEGER NOT NULL CHECK (quantity > 0),
  unit_price DECIMAL(10, 2) NOT NULL,
  total_price DECIMAL(10, 2) NOT NULL,
  delivery_status public.order_status DEFAULT 'pending',
  digital_content_delivered JSONB, -- Actual codes/items delivered
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_orders_buyer_id ON public.orders(buyer_id);
CREATE INDEX idx_orders_status ON public.orders(status);
CREATE INDEX idx_order_items_order_id ON public.order_items(order_id);
CREATE INDEX idx_order_items_seller_id ON public.order_items(seller_id);
CREATE INDEX idx_order_items_variant_id ON public.order_items(variant_id);

-- Comments
COMMENT ON TABLE public.orders IS 'Customer orders';
COMMENT ON TABLE public.order_items IS 'Individual items within an order';
COMMENT ON COLUMN public.orders.discount_amount IS 'Discount amount applied to the order';
COMMENT ON COLUMN public.orders.tax_amount IS 'Tax amount for the order';
COMMENT ON COLUMN public.orders.shipping_address IS 'Shipping address information (JSONB)';
COMMENT ON COLUMN public.orders.billing_address IS 'Billing address information (JSONB)';
COMMENT ON COLUMN public.orders.notes IS 'Order notes or special instructions';
COMMENT ON COLUMN public.orders.subtotal IS 'Subtotal before discount and tax';



-- ============================================
-- File: 06_cart.sql
-- ============================================

-- ============================================
-- CART TABLES
-- ============================================
-- Shopping cart and cart items

CREATE TABLE public.cart_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  variant_id UUID REFERENCES public.product_variants(id) ON DELETE CASCADE NOT NULL,
  quantity INTEGER NOT NULL DEFAULT 1 CHECK (quantity > 0),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, variant_id)
);

-- Indexes
CREATE INDEX idx_cart_items_user_id ON public.cart_items(user_id);
CREATE INDEX idx_cart_items_variant_id ON public.cart_items(variant_id);

-- Comments
COMMENT ON TABLE public.cart_items IS 'Shopping cart items for users';



-- ============================================
-- File: 07_wallets.sql
-- ============================================

-- ============================================
-- WALLET SYSTEM
-- ============================================
-- Multi-currency wallet system

-- Multi-currency wallet system
CREATE TABLE public.wallets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  currency VARCHAR(3) NOT NULL,
  balance DECIMAL(12,2) DEFAULT 0 CHECK (balance >= 0),
  escrow_balance DECIMAL(12,2) DEFAULT 0 CHECK (escrow_balance >= 0),
  bonus_balance DECIMAL(12,2) DEFAULT 0 CHECK (bonus_balance >= 0),
  frozen_balance DECIMAL(12,2) DEFAULT 0 CHECK (frozen_balance >= 0),
  last_updated TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, currency)
);

-- Wallet transactions
CREATE TABLE public.wallet_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  wallet_id UUID NOT NULL REFERENCES public.wallets(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  transaction_type VARCHAR(50) NOT NULL, -- 'deposit', 'withdrawal', 'payment', 'refund', 'bonus', 'fee'
  amount DECIMAL(12,2) NOT NULL,
  currency VARCHAR(3) NOT NULL,
  status VARCHAR(50) NOT NULL DEFAULT 'pending', -- 'pending', 'completed', 'failed', 'cancelled'
  reference_id UUID, -- Reference to order, payment, etc.
  reference_type VARCHAR(50), -- 'order', 'payment', 'refund', etc.
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_wallets_user_id ON public.wallets(user_id);
CREATE INDEX idx_wallets_currency ON public.wallets(currency);
CREATE INDEX idx_wallet_transactions_user_id ON public.wallet_transactions(user_id);
CREATE INDEX idx_wallet_transactions_wallet_id ON public.wallet_transactions(wallet_id);
CREATE INDEX idx_wallet_transactions_status ON public.wallet_transactions(status);

-- Comments
COMMENT ON TABLE public.wallets IS 'Multi-currency user wallets';
COMMENT ON TABLE public.wallet_transactions IS 'Wallet transaction history';



-- ============================================
-- File: 08_campaigns.sql
-- ============================================

-- ============================================
-- CAMPAIGNS & GIVEAWAYS
-- ============================================

-- Campaigns
CREATE TABLE public.campaigns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  creator_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  name TEXT NOT NULL,
  description TEXT,
  campaign_type VARCHAR(50) NOT NULL, -- 'giveaway', 'discount', 'referral', 'stream'
  status VARCHAR(50) NOT NULL DEFAULT 'draft', -- 'draft', 'active', 'paused', 'completed', 'cancelled'
  -- Discount code fields (for campaign_type='discount')
  code VARCHAR(50) UNIQUE, -- Discount code (e.g., 'SAVE20', 'WELCOME10')
  discount_percentage DECIMAL(5,2), -- Percentage discount (e.g., 20.00 for 20%)
  discount_amount DECIMAL(10,2), -- Fixed amount discount
  currency VARCHAR(3) DEFAULT 'USD', -- Currency for discount_amount
  valid_from TIMESTAMPTZ, -- When discount code becomes valid
  valid_until TIMESTAMPTZ, -- When discount code expires
  -- Campaign timing
  start_date TIMESTAMPTZ,
  end_date TIMESTAMPTZ,
  -- Flexible data
  requirements JSONB,
  rewards JSONB,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Giveaway entries
CREATE TABLE public.giveaway_entries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  campaign_id UUID NOT NULL REFERENCES public.campaigns(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  entry_method VARCHAR(50) NOT NULL, -- 'chat_command', 'follow', 'purchase', 'referral'
  is_winner BOOLEAN DEFAULT FALSE,
  prize_claimed BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(campaign_id, user_id)
);

-- Referrals
CREATE TABLE public.referrals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  referrer_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  referred_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  referral_code VARCHAR(50) UNIQUE NOT NULL,
  status VARCHAR(50) NOT NULL DEFAULT 'pending', -- 'pending', 'completed', 'rewarded'
  reward_amount DECIMAL(10,2) DEFAULT 0,
  reward_currency VARCHAR(3) DEFAULT 'TRY',
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_campaigns_creator_id ON public.campaigns(creator_id);
CREATE INDEX idx_campaigns_status ON public.campaigns(status);
CREATE INDEX idx_campaigns_code ON public.campaigns(code) WHERE code IS NOT NULL;
CREATE INDEX idx_campaigns_type ON public.campaigns(campaign_type);
CREATE INDEX idx_giveaway_entries_campaign_id ON public.giveaway_entries(campaign_id);
CREATE INDEX idx_giveaway_entries_user_id ON public.giveaway_entries(user_id);
CREATE INDEX idx_referrals_referrer_id ON public.referrals(referrer_id);
CREATE INDEX idx_referrals_referred_id ON public.referrals(referred_id);

-- Comments
COMMENT ON TABLE public.campaigns IS 'Marketing campaigns and giveaways';
COMMENT ON TABLE public.giveaway_entries IS 'User entries in giveaway campaigns';
COMMENT ON TABLE public.referrals IS 'Referral system tracking';



-- ============================================
-- File: 09_reviews.sql
-- ============================================

-- ============================================
-- REVIEWS & RATINGS
-- ============================================

-- Comprehensive review system
CREATE TABLE public.reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID REFERENCES public.orders(id) ON DELETE CASCADE,
  reviewer_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reviewed_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE, -- Seller being reviewed (optional)
  product_id UUID REFERENCES public.products(id) ON DELETE SET NULL,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  comment TEXT,
  images TEXT[], -- Review photos
  helpful_count INTEGER DEFAULT 0,
  is_verified_purchase BOOLEAN DEFAULT false,
  sentiment_score DECIMAL(3,2), -- AI sentiment analysis (-1 to 1)
  moderation_status public.moderation_status DEFAULT 'pending',
  moderated_by UUID REFERENCES public.profiles(id),
  moderated_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(product_id, reviewer_id, order_id) -- One review per user per product per order
);

-- Review helpful votes
CREATE TABLE public.review_votes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  review_id UUID NOT NULL REFERENCES public.reviews(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  helpful BOOLEAN NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(review_id, user_id)
);

-- Indexes
CREATE INDEX idx_reviews_reviewer_id ON public.reviews(reviewer_id);
CREATE INDEX idx_reviews_reviewed_id ON public.reviews(reviewed_id);
CREATE INDEX idx_reviews_product_id ON public.reviews(product_id);
CREATE INDEX idx_reviews_moderation_status ON public.reviews(moderation_status);
CREATE INDEX idx_reviews_rating ON public.reviews(rating);
CREATE INDEX idx_reviews_created_at ON public.reviews(created_at DESC);

-- Comments
COMMENT ON TABLE public.reviews IS 'Product and seller reviews';
COMMENT ON TABLE public.review_votes IS 'Helpful votes on reviews';



-- ============================================
-- File: 10_forum.sql
-- ============================================

-- ============================================
-- FORUM SYSTEM
-- ============================================

-- Forum categories
CREATE TABLE public.forum_categories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  slug VARCHAR(100) UNIQUE NOT NULL,
  parent_id UUID REFERENCES public.forum_categories(id) ON DELETE SET NULL,
  order_index INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT TRUE,
  -- Alternative structure from production tables
  icon VARCHAR(50),
  post_count INTEGER DEFAULT 0,
  display_order INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Forum posts
CREATE TABLE public.forum_posts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  category_id UUID REFERENCES public.forum_categories(id) ON DELETE SET NULL,
  author_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  views_count INTEGER DEFAULT 0,
  likes_count INTEGER DEFAULT 0,
  replies_count INTEGER DEFAULT 0,
  is_pinned BOOLEAN DEFAULT FALSE,
  is_locked BOOLEAN DEFAULT FALSE,
  moderation_status public.moderation_status DEFAULT 'pending',
  -- Alternative structure from production tables
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  view_count INTEGER DEFAULT 0,
  reply_count INTEGER DEFAULT 0,
  last_reply_at TIMESTAMPTZ,
  tags TEXT[],
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Forum replies
CREATE TABLE public.forum_replies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id UUID NOT NULL REFERENCES public.forum_posts(id) ON DELETE CASCADE,
  author_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  likes_count INTEGER DEFAULT 0,
  moderation_status public.moderation_status DEFAULT 'pending',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_forum_posts_category_id ON public.forum_posts(category_id);
CREATE INDEX idx_forum_posts_author_id ON public.forum_posts(author_id);
CREATE INDEX idx_forum_posts_user_id ON public.forum_posts(user_id);
CREATE INDEX idx_forum_posts_created_at ON public.forum_posts(created_at DESC);
CREATE INDEX idx_forum_posts_is_pinned ON public.forum_posts(is_pinned DESC, created_at DESC);
CREATE INDEX idx_forum_replies_post_id ON public.forum_replies(post_id);
CREATE INDEX idx_forum_categories_display_order ON public.forum_categories(display_order);

-- Comments
COMMENT ON TABLE public.forum_categories IS 'Forum categories';
COMMENT ON TABLE public.forum_posts IS 'Forum posts';
COMMENT ON TABLE public.forum_replies IS 'Forum post replies';



-- ============================================
-- File: 11_messaging.sql
-- ============================================

-- ============================================
-- MESSAGING SYSTEM
-- ============================================

-- Messages table
CREATE TABLE public.messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  receiver_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  order_id UUID REFERENCES public.orders(id) ON DELETE SET NULL,
  content TEXT NOT NULL,
  is_read BOOLEAN DEFAULT false,
  read_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_messages_sender_id ON public.messages(sender_id);
CREATE INDEX idx_messages_receiver_id ON public.messages(receiver_id);
CREATE INDEX idx_messages_order_id ON public.messages(order_id);
CREATE INDEX idx_messages_created_at ON public.messages(created_at DESC);
CREATE INDEX idx_messages_is_read ON public.messages(is_read) WHERE is_read = false;

-- Comments
COMMENT ON TABLE public.messages IS 'User-to-user messages';



-- ============================================
-- File: 12_notifications.sql
-- ============================================

-- ============================================
-- NOTIFICATIONS SYSTEM
-- ============================================

-- Notifications table
CREATE TABLE public.notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  type VARCHAR(50) NOT NULL, -- 'order', 'price_alert', 'recommendation', 'campaign', 'security', 'community'
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  link TEXT,
  is_read BOOLEAN DEFAULT FALSE,
  metadata JSONB, -- Additional data for the notification
  created_at TIMESTAMPTZ DEFAULT NOW(),
  read_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_notifications_user_id ON public.notifications(user_id);
CREATE INDEX idx_notifications_user_read ON public.notifications(user_id, is_read);
CREATE INDEX idx_notifications_created_at ON public.notifications(created_at DESC);

-- Comments
COMMENT ON TABLE public.notifications IS 'User notifications';



-- ============================================
-- File: 13_analytics.sql
-- ============================================

-- ============================================
-- ANALYTICS & TRACKING
-- ============================================

-- User events tracking
CREATE TABLE public.user_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  session_id UUID,
  event_type public.event_type NOT NULL,
  event_data JSONB NOT NULL,
  page_url TEXT,
  referrer TEXT,
  user_agent TEXT,
  ip_address INET,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_user_events_user_id ON public.user_events(user_id);
CREATE INDEX idx_user_events_event_type ON public.user_events(event_type);
CREATE INDEX idx_user_events_created_at ON public.user_events(created_at);

-- Comments
COMMENT ON TABLE public.user_events IS 'User behavior tracking and analytics';



-- ============================================
-- File: 14_admin.sql
-- ============================================

-- ============================================
-- ADMIN & SECURITY TABLES
-- ============================================

-- Escrow transactions
CREATE TABLE public.escrows (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID REFERENCES public.orders(id) ON DELETE CASCADE,
  buyer_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  seller_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  amount DECIMAL(12,2) NOT NULL CHECK (amount > 0),
  currency VARCHAR(3) NOT NULL DEFAULT 'TRY',
  status public.escrow_status NOT NULL DEFAULT 'initiated',
  delivery_window_hours INTEGER DEFAULT 24,
  dispute_window_hours INTEGER DEFAULT 72,
  auto_release_hours INTEGER DEFAULT 168,
  seller_confirmed BOOLEAN DEFAULT FALSE,
  buyer_confirmed BOOLEAN DEFAULT FALSE,
  expiry_time TIMESTAMPTZ,
  dispute_window_end TIMESTAMPTZ,
  auto_release_time TIMESTAMPTZ,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Disputes table
CREATE TABLE public.disputes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES public.orders(id) ON DELETE CASCADE,
  escrow_id UUID REFERENCES public.escrows(id) ON DELETE SET NULL,
  buyer_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  seller_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  dispute_type VARCHAR(50) NOT NULL, -- 'non_delivery', 'wrong_product', 'invalid_code', 'late_delivery', 'other'
  status VARCHAR(50) NOT NULL DEFAULT 'open', -- 'open', 'under_review', 'resolved_buyer', 'resolved_seller', 'closed'
  buyer_claim TEXT,
  seller_response TEXT,
  evidence JSONB, -- Array of evidence URLs, screenshots, etc.
  ai_score DECIMAL(3,2), -- AI-generated dispute score (0-1)
  resolution VARCHAR(50), -- 'refund_buyer', 'favor_seller', 'partial_refund', 'no_action'
  resolved_by UUID REFERENCES public.profiles(id), -- Admin who resolved
  resolved_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Comprehensive audit trail
CREATE TABLE public.audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  admin_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  action_type public.audit_action NOT NULL,
  resource_type VARCHAR(50) NOT NULL,
  resource_id UUID,
  old_values JSONB,
  new_values JSONB,
  ip_address INET,
  user_agent TEXT,
  session_id UUID,
  additional_context JSONB,
  timestamp TIMESTAMPTZ DEFAULT NOW(),
  -- Alternative structure from production tables
  actor_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  actor_type VARCHAR(20) NOT NULL, -- 'user', 'admin', 'system'
  action VARCHAR(100) NOT NULL,
  metadata JSONB
);

-- Security Alerts Table
CREATE TABLE public.security_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  transaction_id UUID REFERENCES public.wallet_transactions(id) ON DELETE SET NULL,
  type VARCHAR(50) NOT NULL, -- 'error', 'warning', 'info'
  title VARCHAR(255) NOT NULL,
  message TEXT NOT NULL,
  severity VARCHAR(20) NOT NULL DEFAULT 'info', -- 'critical', 'warning', 'info'
  status VARCHAR(20) NOT NULL DEFAULT 'unacknowledged', -- 'unacknowledged', 'acknowledged', 'resolved'
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Risk Reviews Table
CREATE TABLE public.risk_reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  transaction_id VARCHAR(50),
  risk_score INTEGER NOT NULL CHECK (risk_score >= 0 AND risk_score <= 100),
  reason TEXT NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'pending', -- 'pending', 'blocked', 'cleared'
  reviewed_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  reviewed_at TIMESTAMPTZ,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- System Alerts Table
CREATE TABLE public.system_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  severity VARCHAR(20) NOT NULL, -- 'critical', 'warning', 'info'
  alert_name VARCHAR(255) NOT NULL,
  message TEXT,
  status VARCHAR(20) NOT NULL DEFAULT 'unacknowledged', -- 'unacknowledged', 'acknowledged', 'resolved'
  acknowledged_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  acknowledged_at TIMESTAMPTZ,
  resolved_at TIMESTAMPTZ,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Support Conversations Table
CREATE TABLE public.support_conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'open', -- 'open', 'closed'
  handled_by VARCHAR(20) NOT NULL DEFAULT 'ai', -- 'ai', 'agent'
  last_message TEXT,
  last_message_time TIMESTAMPTZ DEFAULT NOW(),
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Gamification System
-- Achievements
CREATE TABLE public.achievements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code VARCHAR(100) UNIQUE NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  tier public.achievement_tier NOT NULL,
  icon_url TEXT,
  xp_reward INTEGER DEFAULT 0,
  badge_url TEXT,
  requirements JSONB, -- Achievement requirements
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- User achievements
CREATE TABLE public.user_achievements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  achievement_id UUID NOT NULL REFERENCES public.achievements(id) ON DELETE CASCADE,
  progress JSONB, -- Progress tracking
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, achievement_id)
);

-- User XP and levels
CREATE TABLE public.user_stats (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL UNIQUE REFERENCES public.profiles(id) ON DELETE CASCADE,
  total_xp INTEGER DEFAULT 0,
  current_level INTEGER DEFAULT 1,
  badges_count INTEGER DEFAULT 0,
  achievements_count INTEGER DEFAULT 0,
  reviews_written INTEGER DEFAULT 0,
  purchases_count INTEGER DEFAULT 0,
  sales_count INTEGER DEFAULT 0,
  total_spent DECIMAL(12,2) DEFAULT 0,
  total_earned DECIMAL(12,2) DEFAULT 0,
  last_active_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_escrows_buyer_id ON public.escrows(buyer_id);
CREATE INDEX idx_escrows_seller_id ON public.escrows(seller_id);
CREATE INDEX idx_escrows_order_id ON public.escrows(order_id);
CREATE INDEX idx_escrows_status ON public.escrows(status);
CREATE INDEX idx_disputes_buyer_id ON public.disputes(buyer_id);
CREATE INDEX idx_disputes_seller_id ON public.disputes(seller_id);
CREATE INDEX idx_disputes_order_id ON public.disputes(order_id);
CREATE INDEX idx_disputes_status ON public.disputes(status);
CREATE INDEX idx_audit_logs_user_id ON public.audit_logs(user_id);
CREATE INDEX idx_audit_logs_action_type ON public.audit_logs(action_type);
CREATE INDEX idx_audit_logs_timestamp ON public.audit_logs(timestamp);
CREATE INDEX idx_audit_logs_actor_id ON public.audit_logs(actor_id);
CREATE INDEX idx_audit_logs_action ON public.audit_logs(action);
CREATE INDEX idx_audit_logs_resource ON public.audit_logs(resource_type, resource_id);
CREATE INDEX idx_security_alerts_user_id ON public.security_alerts(user_id);
CREATE INDEX idx_security_alerts_transaction_id ON public.security_alerts(transaction_id);
CREATE INDEX idx_security_alerts_type ON public.security_alerts(type);
CREATE INDEX idx_security_alerts_status ON public.security_alerts(status);
CREATE INDEX idx_security_alerts_created_at ON public.security_alerts(created_at DESC);
CREATE INDEX idx_risk_reviews_user_id ON public.risk_reviews(user_id);
CREATE INDEX idx_risk_reviews_status ON public.risk_reviews(status);
CREATE INDEX idx_risk_reviews_risk_score ON public.risk_reviews(risk_score DESC);
CREATE INDEX idx_risk_reviews_created_at ON public.risk_reviews(created_at DESC);
CREATE INDEX idx_system_alerts_severity ON public.system_alerts(severity);
CREATE INDEX idx_system_alerts_status ON public.system_alerts(status);
CREATE INDEX idx_system_alerts_created_at ON public.system_alerts(created_at DESC);
CREATE INDEX idx_support_conversations_user_id ON public.support_conversations(user_id);
CREATE INDEX idx_support_conversations_status ON public.support_conversations(status);
CREATE INDEX idx_support_conversations_created_at ON public.support_conversations(created_at DESC);
CREATE INDEX idx_user_achievements_user_id ON public.user_achievements(user_id);
CREATE INDEX idx_user_stats_user_id ON public.user_stats(user_id);

-- Comments
COMMENT ON TABLE public.escrows IS 'Escrow transactions for order payments';
COMMENT ON TABLE public.disputes IS 'Order disputes between buyers and sellers';
COMMENT ON TABLE public.audit_logs IS 'Comprehensive audit trail';
COMMENT ON TABLE public.security_alerts IS 'Security alerts for users';
COMMENT ON TABLE public.risk_reviews IS 'Risk assessment reviews';
COMMENT ON TABLE public.system_alerts IS 'System-wide alerts';
COMMENT ON TABLE public.support_conversations IS 'Customer support conversations';
COMMENT ON TABLE public.achievements IS 'Gamification achievements';
COMMENT ON TABLE public.user_achievements IS 'User achievement progress';
COMMENT ON TABLE public.user_stats IS 'User statistics and XP';



-- ============================================
-- File: 15_functions.sql
-- ============================================

-- ============================================
-- DATABASE FUNCTIONS & TRIGGERS
-- ============================================

-- Function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  metadata JSONB := COALESCE(new.raw_user_meta_data, '{}'::jsonb);
BEGIN
  INSERT INTO public.profiles (id, full_name, avatar_url, phone, role, kyc_status)
  VALUES (
    new.id,
    metadata->>'full_name',
    metadata->>'avatar_url',
    metadata->>'phone',
    CASE
      WHEN metadata ? 'role'
        AND metadata->>'role' = ANY (ARRAY['buyer', 'seller', 'creator', 'admin'])
      THEN (metadata->>'role')::public.user_role
      ELSE 'buyer'
    END,
    CASE
      WHEN metadata ? 'kyc_status'
        AND metadata->>'kyc_status' = ANY (ARRAY['not_started', 'pending', 'verified', 'rejected'])
      THEN (metadata->>'kyc_status')::public.kyc_status
      ELSE 'not_started'
    END
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to call the function on new user creation
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Function to update cart item timestamp
CREATE OR REPLACE FUNCTION public.update_cart_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for cart items updated_at
DROP TRIGGER IF EXISTS cart_items_update_updated_at ON public.cart_items;
CREATE TRIGGER cart_items_update_updated_at
  BEFORE UPDATE ON public.cart_items
  FOR EACH ROW
  EXECUTE FUNCTION public.update_cart_updated_at();

-- Function to mark notification as read
CREATE OR REPLACE FUNCTION public.mark_notification_read(notification_id UUID)
RETURNS void AS $$
BEGIN
  UPDATE public.notifications
  SET is_read = TRUE, read_at = NOW()
  WHERE id = notification_id;
END;
$$ LANGUAGE plpgsql;

-- Function to mark all notifications as read for a user
CREATE OR REPLACE FUNCTION public.mark_all_notifications_read(user_uuid UUID)
RETURNS void AS $$
BEGIN
  UPDATE public.notifications
  SET is_read = TRUE, read_at = NOW()
  WHERE user_id = user_uuid AND is_read = FALSE;
END;
$$ LANGUAGE plpgsql;

-- Function to update messages updated_at
CREATE OR REPLACE FUNCTION public.update_messages_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for messages updated_at
DROP TRIGGER IF EXISTS update_messages_updated_at ON public.messages;
CREATE TRIGGER update_messages_updated_at
  BEFORE UPDATE ON public.messages
  FOR EACH ROW
  EXECUTE FUNCTION public.update_messages_updated_at();

-- Database function for atomic stock decrement
CREATE OR REPLACE FUNCTION public.decrement_stock(
  p_variant_id UUID,
  p_quantity INTEGER
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_current_stock INTEGER;
BEGIN
  -- Lock the row for update
  SELECT stock_quantity INTO v_current_stock
  FROM public.product_variants
  WHERE id = p_variant_id
  FOR UPDATE;

  -- Check if enough stock
  IF v_current_stock < p_quantity THEN
    RAISE EXCEPTION 'Insufficient stock. Available: %, Requested: %', v_current_stock, p_quantity;
  END IF;

  -- Decrement stock
  UPDATE public.product_variants
  SET stock_quantity = stock_quantity - p_quantity,
      updated_at = NOW()
  WHERE id = p_variant_id;

  RETURN TRUE;
END;
$$;

-- Database function for seller statistics
CREATE OR REPLACE FUNCTION public.get_seller_stats(p_seller_id UUID)
RETURNS TABLE (
  total_products BIGINT,
  active_products BIGINT,
  total_orders BIGINT,
  pending_orders BIGINT,
  total_revenue NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    (SELECT COUNT(*) FROM public.products WHERE seller_id = p_seller_id) AS total_products,
    (SELECT COUNT(*) FROM public.products WHERE seller_id = p_seller_id AND status = 'active') AS active_products,
    (SELECT COUNT(*) FROM public.order_items WHERE seller_id = p_seller_id) AS total_orders,
    (SELECT COUNT(*) FROM public.order_items WHERE seller_id = p_seller_id AND delivery_status = 'pending') AS pending_orders,
    (SELECT COALESCE(SUM(total_price), 0) FROM public.order_items WHERE seller_id = p_seller_id) AS total_revenue;
END;
$$;

-- Generic function to update updated_at column
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers for updated_at columns
DROP TRIGGER IF EXISTS update_security_alerts_updated_at ON public.security_alerts;
CREATE TRIGGER update_security_alerts_updated_at
  BEFORE UPDATE ON public.security_alerts
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_risk_reviews_updated_at ON public.risk_reviews;
CREATE TRIGGER update_risk_reviews_updated_at
  BEFORE UPDATE ON public.risk_reviews
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_system_alerts_updated_at ON public.system_alerts;
CREATE TRIGGER update_system_alerts_updated_at
  BEFORE UPDATE ON public.system_alerts
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_support_conversations_updated_at ON public.support_conversations;
CREATE TRIGGER update_support_conversations_updated_at
  BEFORE UPDATE ON public.support_conversations
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_reviews_updated_at ON public.reviews;
CREATE TRIGGER update_reviews_updated_at
  BEFORE UPDATE ON public.reviews
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

DROP TRIGGER IF EXISTS update_forum_posts_updated_at ON public.forum_posts;
CREATE TRIGGER update_forum_posts_updated_at
  BEFORE UPDATE ON public.forum_posts
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- Comments
COMMENT ON FUNCTION public.decrement_stock IS 'Atomically decrements product variant stock with validation';
COMMENT ON FUNCTION public.get_seller_stats IS 'Returns aggregate statistics for a seller';



-- ============================================
-- File: 16_policies.sql
-- ============================================

-- ============================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================
-- Enable RLS on all tables and create policies

-- ============================================
-- PROFILES
-- ============================================
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public profiles are viewable by everyone."
  ON public.profiles FOR SELECT
  USING ( true );

CREATE POLICY "Users can insert their own profile."
  ON public.profiles FOR INSERT
  WITH CHECK ( auth.uid() = id );

CREATE POLICY "Users can update own profile."
  ON public.profiles FOR UPDATE
  USING ( auth.uid() = id );

-- ============================================
-- CATEGORIES
-- ============================================
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public categories are viewable by everyone."
  ON public.categories FOR SELECT
  USING ( true );

CREATE POLICY "Admins can insert categories."
  ON public.categories FOR INSERT
  WITH CHECK (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
  );

CREATE POLICY "Admins can update categories."
  ON public.categories FOR UPDATE
  USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
  );

CREATE POLICY "Admins can delete categories."
  ON public.categories FOR DELETE
  USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
  );

-- ============================================
-- PRODUCTS
-- ============================================
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Active products are viewable by everyone."
  ON public.products FOR SELECT
  USING ( status = 'active' );

CREATE POLICY "Sellers can view their own products."
  ON public.products FOR SELECT
  USING ( auth.uid() = seller_id );

CREATE POLICY "Sellers can create products."
  ON public.products FOR INSERT
  WITH CHECK ( auth.uid() = seller_id );

CREATE POLICY "Sellers can update their own products."
  ON public.products FOR UPDATE
  USING ( auth.uid() = seller_id );

-- ============================================
-- PRODUCT VARIANTS
-- ============================================
ALTER TABLE public.product_variants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Active product variants are viewable by everyone."
  ON public.product_variants FOR SELECT
  USING ( status = 'active' );

CREATE POLICY "Sellers can manage their own variants."
  ON public.product_variants FOR ALL
  USING ( auth.uid() IN (SELECT seller_id FROM public.products WHERE id = product_id) );

-- ============================================
-- ATTRIBUTES
-- ============================================
ALTER TABLE public.attributes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Attributes are public."
  ON public.attributes FOR SELECT
  USING ( true );

CREATE POLICY "Admins can insert attributes."
  ON public.attributes FOR INSERT
  WITH CHECK (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
  );

CREATE POLICY "Admins can update attributes."
  ON public.attributes FOR UPDATE
  USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
  );

CREATE POLICY "Admins can delete attributes."
  ON public.attributes FOR DELETE
  USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
  );

-- ============================================
-- PRODUCT VARIANT ATTRIBUTES
-- ============================================
ALTER TABLE public.product_variant_attributes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Variant attributes are public."
  ON public.product_variant_attributes FOR SELECT
  USING ( true );

CREATE POLICY "Sellers can manage their product variant attributes."
  ON public.product_variant_attributes FOR ALL
  USING (
    auth.uid() IN (
      SELECT p.seller_id
      FROM public.products p
      JOIN public.product_variants pv ON pv.product_id = p.id
      WHERE pv.id = variant_id
    )
  );

-- ============================================
-- CART ITEMS
-- ============================================
ALTER TABLE public.cart_items ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own cart."
  ON public.cart_items FOR SELECT
  USING ( auth.uid() = user_id );

CREATE POLICY "Users can add to their own cart."
  ON public.cart_items FOR INSERT
  WITH CHECK ( auth.uid() = user_id );

CREATE POLICY "Users can update their own cart."
  ON public.cart_items FOR UPDATE
  USING ( auth.uid() = user_id );

CREATE POLICY "Users can delete from their own cart."
  ON public.cart_items FOR DELETE
  USING ( auth.uid() = user_id );

-- ============================================
-- ORDERS
-- ============================================
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Buyers can view their own orders."
  ON public.orders FOR SELECT
  USING ( auth.uid() = buyer_id );

CREATE POLICY "Buyers can create orders."
  ON public.orders FOR INSERT
  WITH CHECK ( auth.uid() = buyer_id );

CREATE POLICY "Buyers can update their pending orders."
  ON public.orders FOR UPDATE
  USING ( auth.uid() = buyer_id AND status = 'pending' );

-- ============================================
-- ORDER ITEMS
-- ============================================
ALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Buyers can view their order items."
  ON public.order_items FOR SELECT
  USING ( auth.uid() IN (SELECT buyer_id FROM public.orders WHERE id = order_id) );

CREATE POLICY "Buyers can create order items during checkout."
  ON public.order_items FOR INSERT
  WITH CHECK (
    auth.uid() IN (SELECT buyer_id FROM public.orders WHERE id = order_id)
  );

CREATE POLICY "Sellers can view their order items."
  ON public.order_items FOR SELECT
  USING ( auth.uid() = seller_id );

CREATE POLICY "Sellers can update their order items."
  ON public.order_items FOR UPDATE
  USING ( auth.uid() = seller_id );

-- ============================================
-- WALLETS
-- ============================================
ALTER TABLE public.wallets ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own wallets" ON public.wallets
  FOR SELECT USING (auth.uid() = user_id);

-- ============================================
-- WALLET TRANSACTIONS
-- ============================================
ALTER TABLE public.wallet_transactions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own transactions" ON public.wallet_transactions
  FOR SELECT USING (auth.uid() = user_id);

-- ============================================
-- ESCROWS
-- ============================================
ALTER TABLE public.escrows ENABLE ROW LEVEL SECURITY;

-- Basic escrow policies (can be expanded)
CREATE POLICY "Buyers and sellers can view their escrows" ON public.escrows
  FOR SELECT USING (auth.uid() = buyer_id OR auth.uid() = seller_id);

-- ============================================
-- DISPUTES
-- ============================================
ALTER TABLE public.disputes ENABLE ROW LEVEL SECURITY;

-- Basic dispute policies (can be expanded)
CREATE POLICY "Buyers and sellers can view their disputes" ON public.disputes
  FOR SELECT USING (auth.uid() = buyer_id OR auth.uid() = seller_id);

-- ============================================
-- REVIEWS
-- ============================================
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public can view approved reviews" ON public.reviews
  FOR SELECT USING (moderation_status = 'approved');

CREATE POLICY "Anyone can view reviews" ON public.reviews
  FOR SELECT USING (true);

CREATE POLICY "Users can create reviews for their orders" ON public.reviews
  FOR INSERT
  WITH CHECK (
    auth.uid() = reviewer_id AND
    EXISTS (
      SELECT 1 FROM public.orders
      WHERE orders.id = order_id
      AND orders.buyer_id = auth.uid()
      AND orders.status IN ('completed', 'delivered')
    )
  );

CREATE POLICY "Users can update their own reviews" ON public.reviews
  FOR UPDATE USING (auth.uid() = reviewer_id);

-- ============================================
-- REVIEW VOTES
-- ============================================
ALTER TABLE public.review_votes ENABLE ROW LEVEL SECURITY;

-- Basic review vote policies (can be expanded)
CREATE POLICY "Users can manage their own review votes" ON public.review_votes
  FOR ALL USING (auth.uid() = user_id);

-- ============================================
-- USER STATS
-- ============================================
ALTER TABLE public.user_stats ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own stats" ON public.user_stats
  FOR SELECT USING (auth.uid() = user_id);

-- ============================================
-- FORUM POSTS
-- ============================================
ALTER TABLE public.forum_posts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public can view approved posts" ON public.forum_posts
  FOR SELECT USING (moderation_status = 'approved' OR auth.uid() = author_id);

CREATE POLICY "Anyone can view forum posts" ON public.forum_posts
  FOR SELECT USING (true);

CREATE POLICY "Authenticated users can create forum posts" ON public.forum_posts
  FOR INSERT WITH CHECK (auth.uid() = author_id OR auth.uid() = user_id);

CREATE POLICY "Users can update their own forum posts" ON public.forum_posts
  FOR UPDATE USING (auth.uid() = author_id OR auth.uid() = user_id);

-- ============================================
-- FORUM REPLIES
-- ============================================
ALTER TABLE public.forum_replies ENABLE ROW LEVEL SECURITY;

-- Basic forum reply policies (can be expanded)
CREATE POLICY "Public can view approved replies" ON public.forum_replies
  FOR SELECT USING (moderation_status = 'approved' OR auth.uid() = author_id);

-- ============================================
-- FORUM CATEGORIES
-- ============================================
ALTER TABLE public.forum_categories ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view forum categories" ON public.forum_categories
  FOR SELECT USING (true);

CREATE POLICY "Admins can manage forum categories" ON public.forum_categories
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
  );

-- ============================================
-- MESSAGES
-- ============================================
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own messages"
  ON public.messages FOR SELECT
  USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

CREATE POLICY "Users can insert their own messages"
  ON public.messages FOR INSERT
  WITH CHECK (auth.uid() = sender_id);

CREATE POLICY "Users can update received messages"
  ON public.messages FOR UPDATE
  USING (auth.uid() = receiver_id)
  WITH CHECK (auth.uid() = receiver_id);

-- ============================================
-- NOTIFICATIONS
-- ============================================
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own notifications"
  ON public.notifications FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own notifications"
  ON public.notifications FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert notifications"
  ON public.notifications FOR INSERT
  WITH CHECK (auth.uid() = user_id OR auth.jwt() ->> 'role' = 'service_role');

-- ============================================
-- USER EVENTS
-- ============================================
ALTER TABLE public.user_events ENABLE ROW LEVEL SECURITY;

-- Basic user events policies (can be expanded)
CREATE POLICY "Users can view their own events" ON public.user_events
  FOR SELECT USING (auth.uid() = user_id);

-- ============================================
-- AUDIT LOGS
-- ============================================
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can view all audit logs" ON public.audit_logs
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
  );

CREATE POLICY "System can insert audit logs" ON public.audit_logs
  FOR INSERT WITH CHECK (auth.jwt() ->> 'role' = 'service_role' OR auth.uid() = actor_id OR auth.uid() = user_id);

-- ============================================
-- CAMPAIGNS
-- ============================================
ALTER TABLE public.campaigns ENABLE ROW LEVEL SECURITY;

-- Basic campaign policies (can be expanded)
CREATE POLICY "Public can view active campaigns" ON public.campaigns
  FOR SELECT USING (status = 'active');

-- ============================================
-- GIVEAWAY ENTRIES
-- ============================================
ALTER TABLE public.giveaway_entries ENABLE ROW LEVEL SECURITY;

-- Basic giveaway entry policies (can be expanded)
CREATE POLICY "Users can view their own entries" ON public.giveaway_entries
  FOR SELECT USING (auth.uid() = user_id);

-- ============================================
-- REFERRALS
-- ============================================
ALTER TABLE public.referrals ENABLE ROW LEVEL SECURITY;

-- Basic referral policies (can be expanded)
CREATE POLICY "Users can view their own referrals" ON public.referrals
  FOR SELECT USING (auth.uid() = referrer_id OR auth.uid() = referred_id);

-- ============================================
-- SECURITY ALERTS
-- ============================================
ALTER TABLE public.security_alerts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can view all security alerts"
  ON public.security_alerts FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

CREATE POLICY "System can insert security alerts"
  ON public.security_alerts FOR INSERT
  WITH CHECK (auth.jwt() ->> 'role' = 'service_role' OR auth.uid() = user_id);

-- ============================================
-- RISK REVIEWS
-- ============================================
ALTER TABLE public.risk_reviews ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can view all risk reviews"
  ON public.risk_reviews FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

CREATE POLICY "System can insert risk reviews"
  ON public.risk_reviews FOR INSERT
  WITH CHECK (auth.jwt() ->> 'role' = 'service_role');

CREATE POLICY "Admins can update risk reviews"
  ON public.risk_reviews FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

-- ============================================
-- SYSTEM ALERTS
-- ============================================
ALTER TABLE public.system_alerts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can view all system alerts"
  ON public.system_alerts FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

CREATE POLICY "System can insert system alerts"
  ON public.system_alerts FOR INSERT
  WITH CHECK (auth.jwt() ->> 'role' = 'service_role');

CREATE POLICY "Admins can update system alerts"
  ON public.system_alerts FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid()
      AND profiles.role = 'admin'
    )
  );

-- ============================================
-- SUPPORT CONVERSATIONS
-- ============================================
ALTER TABLE public.support_conversations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own support conversations"
  ON public.support_conversations FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create support conversations"
  ON public.support_conversations FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own support conversations"
  ON public.support_conversations FOR UPDATE
  USING (auth.uid() = user_id);

-- ============================================
-- ACHIEVEMENTS
-- ============================================
ALTER TABLE public.achievements ENABLE ROW LEVEL SECURITY;

-- Basic achievement policies (can be expanded)
CREATE POLICY "Public can view active achievements" ON public.achievements
  FOR SELECT USING (is_active = true);

-- ============================================
-- USER ACHIEVEMENTS
-- ============================================
ALTER TABLE public.user_achievements ENABLE ROW LEVEL SECURITY;

-- Basic user achievement policies (can be expanded)
CREATE POLICY "Users can view their own achievements" ON public.user_achievements
  FOR SELECT USING (auth.uid() = user_id);



-- ============================================
-- File: 17_storage.sql
-- ============================================

-- ============================================
-- STORAGE BUCKETS & POLICIES
-- ============================================

-- Set up Storage security policies for user avatars
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true)
ON CONFLICT (id) DO NOTHING;

-- Avatar policies
CREATE POLICY "Avatar images are publicly accessible." ON storage.objects
  FOR SELECT USING (bucket_id = 'avatars');

CREATE POLICY "Anyone can upload an avatar." ON storage.objects
  FOR INSERT WITH CHECK (bucket_id = 'avatars');

CREATE POLICY "Users can update their own avatar." ON storage.objects
  FOR UPDATE WITH CHECK (auth.uid() = owner AND bucket_id = 'avatars');

CREATE POLICY "Users can delete their own avatar." ON storage.objects
  FOR DELETE USING (auth.uid() = owner AND bucket_id = 'avatars');

-- Product images bucket (if needed)
INSERT INTO storage.buckets (id, name, public)
VALUES ('product-images', 'product-images', true)
ON CONFLICT (id) DO NOTHING;

-- Product image policies
CREATE POLICY "Product images are publicly accessible." ON storage.objects
  FOR SELECT USING (bucket_id = 'product-images');

CREATE POLICY "Sellers can upload product images." ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'product-images' AND
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND role IN ('seller', 'admin')
    )
  );

CREATE POLICY "Sellers can update their product images." ON storage.objects
  FOR UPDATE WITH CHECK (
    bucket_id = 'product-images' AND
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND role IN ('seller', 'admin')
    )
  );

CREATE POLICY "Sellers can delete their product images." ON storage.objects
  FOR DELETE USING (
    bucket_id = 'product-images' AND
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND role IN ('seller', 'admin')
    )
  );

-- Category icons bucket (if needed)
INSERT INTO storage.buckets (id, name, public)
VALUES ('category-icons', 'category-icons', true)
ON CONFLICT (id) DO NOTHING;

-- Category icon policies
CREATE POLICY "Category icons are publicly accessible." ON storage.objects
  FOR SELECT USING (bucket_id = 'category-icons');

CREATE POLICY "Admins can upload category icons." ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'category-icons' AND
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND role = 'admin'
    )
  );

CREATE POLICY "Admins can update category icons." ON storage.objects
  FOR UPDATE WITH CHECK (
    bucket_id = 'category-icons' AND
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND role = 'admin'
    )
  );

CREATE POLICY "Admins can delete category icons." ON storage.objects
  FOR DELETE USING (
    bucket_id = 'category-icons' AND
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND role = 'admin'
    )
  );



